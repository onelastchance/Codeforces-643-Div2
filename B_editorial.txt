Let's sort all the explorers by non-decreasing inexperience. Suppose we have formed some group, how can we check is this group is valid? Inexperience of all the explorers in the group should be not greater than the group size. But we have sorted all the explorers, so the last explorer from the group has the largest inexperience. Therefore, to check the group for validity it is necessary and sufficient to check that inexperience of the last explorer is not greater than the group size.

We can notice that we don't even look at all the explorers except the last one, the only important thing is their number. In fact, we can organize the creation of groups in this way: first choose the explorers that will be the last in their groups, then assign sufficient number of other explorers to corresponding groups. It is not profitable to assign more explorers than needed for this particular last explorer, because we can always leave them at the camp.

So how should we choose the last explorers? We want to make more groups, so the groups themselves should me smaller... It is tempting to use the following greedy algorithm: let's greedily pick the leftmost (which means with the smallest necessary group size) explorer such that they have enough explorers to the left of them to create a valid group. The idea is that we spend the smallest number of explorers and leave the most potential last explorers in the future. Let's strictly prove this greedy:

The solution is defined by positions of the last explorers in their corresponding groups 1≤p1<p2<…<pk≤n. Notice that the solution is valid if and only if ep1+ep2+…+epi≤pi for all 1≤i≤k (we always have enough explorers to form first i groups).

Let 1≤p1<p2<…<pk≤n be the greedy solution and 1≤q1<q2<…<qm≤n be the optimal solution such that it has the largest common prefix with greedy one among all optimal solutions. Let t be the position of first difference in these solutions. t≤k since otherwise the greedy algorithm couldn't add one more group but it was possible. pt<qt since otherwise the greedy algorithm would take qt instead of pt. Since the explorers are sorted we have ept≤eqt. But then 1≤q1<q2<…<qt−1<pt<qt+1<…<qm≤n is a valid optimal solution and it has strictly larger common prefix with the greedy one which contradicts the choosing of our optimal solution.

To implement this solution it is enough to sort the explorers by the non-decreasing inexperience, then go from left to right and maintain the number of unused explorers. As soon as we encounter the possibility to create a new group, we do it.